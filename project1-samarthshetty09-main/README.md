[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/tHiBWNx1)
# Project 1: Getting Acquainted with XINU

## 1. Objective
The objective of this introductory lab is to familiarize you with the process of compiling and running XINU, the tools involved, and the run-time environment and segment layout.

## 2. Setup Guide
XINU is a small Unix-like operating system originally developed by Douglas Comer for instructional purposes at Purdue University. It is small enough so that we can understand it entirely within one semester. As part of lab assignments, we will re-implement or improve some aspects of XINU.

- Step 1: Setting up a development environment:

    We are going to use a customized VCL image -- XINU+QEMU (CSC501) -- through the [VCL](http://vcl.ncsu.edu/) facility.

- Step 2: Clone the project repository:
    
    1. Change to a working directory you would like to use for this project. If you are using a university computer, you want to store your files on some storage that is permanent and accessible from other university computers. You can use [ncsudrive](https://oit.ncsu.edu/file-space/ncsu-drive/). It is already mounted on your VCL VM: `/mnt/ncsudrive/__first_letter_of_your_unity_id__/__your_unity_id__/`. If your unity ID is `xinurocks`, your ncsudrive is mounted at `/mnt/ncsudrive/x/xinurocks`. 
        ```shell
        cd /mnt/ncsudrive/__first_letter_of_your_unity_id__/__your_unity_id__/
        ```
        If you do not have an ncsudrive already, you'll need to log into remote.eos.ncsu.edu to create the drive.
        ```shell
        ssh __your_unity_id__@remote.eos.ncsu.edu
        ```

    2. Clone this repository in your working directory. 
        ```shell
        git clone https://github.com/.....
        ```
        Go to the project directory. The subdirectories under this repository contain source code, header files, etc, for XINU.

- Step 3: Building XINU

    To compile the XINU kernel, run `make` in the `compile` directory as follows:

    ```shell
    cd compile
    make depend
    make
    ```
    This creates an OS image called `xinu.elf`.

- Step 4: Running and debugging XINU

    The XINU image runs on the QEMU emulator machines. To boot up the image, type:
    ```shell
    make run
    ```
    XINU should start running and print messages.

    Typing `Ctrl-a` then `c` (not `Ctrl-c`, make sure you release the `Ctrl` key) will always bring you to "(qemu)" prompt. From there, you can quit by typing `q`.

    To debug XINU, run the image in the **debug mode** by:
    ```shell
    make debug
    ```
    Then execute GDB in **another ssh session**:
    ```shell
    gdb xinu.elf
    ```
    In the (gdb) console, connect to the remote server by:
    ```
    target remote localhost:1234
    ```
    You can use many debugging features provided by GDB, e.g., adding a break point at the main function:
    ```
    b main
    ```
    To run to the next breakpoint, type:
    ```
    c
    ```
    The detailed document for GDB can be found [here](https://www.sourceware.org/gdb).

## 3. Readings

- AT&T assembly information specific to the GNU assembler is available [here](http://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax) as a wikibook.
- [Intel 64 and IA-32 Architectures Software Developer's Manual](https://cdrdv2.intel.com/v1/dl/getContent/671200)
- Any man pages/manuals you discover that you need.


## 4. Tasks

You are asked to write several XINU functions that perform the following tasks:

1. `long zfunction(long param)`

    This function performs a number of operations on the parameter `param` and then returns it. These operations are:
    - Clear the 20th to 27th bits, counting from the left starting with 0.
    - Shift by 8 bits to the left.
    - Fill the right-most 8 bits with 1s.
    
    For example, the input parameter `0xaabbccdd` should generate a return value of `0xbbc00dff`. You can assume that the size of long is 4 bytes. The code for this function should be entirely written in x86 assembly. You should not use inline assembly, (i.e., do not use asm(???)). To investigate the assembly code generated by the compiler, you can use the tool `objdump -d <___.o>` to disassemble an object file. The object files reside in the [compile](compile) directory within the main Xinu directory. You can also see some of the *.S files in the [sys](sys) directory for reference.

3. `void printprocstks(int priority)`

    For each existing process with larger priority than the parameter, print the stack base, stack size, stacklimit, and stack pointer. Also, for each process, include the process name, the process id and the process priority.

    To help you do this, please look into [h/proc.h](h/proc.h). Note the `proctab[]` array that holds all processes. Also, note that the `pesp` member of the `pentry` structure holds the saved stack pointer. Therefore, the currently executing process has a stack pointer that is different from the value of this variable. In order to help you get the stack pointer of the currently executing process, carefully study the [sys/stacktrace.c](sys/stacktrace.c) file. The register `%esp` holds the current stack pointer. You can use in-line assembly(i.e., `asm("...")`) to do this part.

4. `void printsyscallsummary()`

    Print the summary of the system calls which have been invoked for each process. This task is loosely based on the functionality of [LTTng](http://lttng.org/). There are 43 system calls declared. Please look into [h/kernel.h](h/kernel.h) to see all declared system calls. However, only 27 system calls are implemented in this XINU version. You will need to trace these system calls:    
    ```c    
    SYSCALL	freemem(struct mblock *block, unsigned size);
    SYSCALL chprio(int pid, int newprio);
    SYSCALL getpid();
    SYSCALL getprio(int pid);
    SYSCALL	gettime(long *timvar);
    SYSCALL kill(int pid);
    SYSCALL	receive();
    SYSCALL	recvclr();
    SYSCALL	recvtim(int maxwait);
    SYSCALL resume(int pid);
    SYSCALL scount(int sem);
    SYSCALL sdelete(int sem);
    SYSCALL	send(int pid, WORD msg);
    SYSCALL	setdev(int pid, int dev1, int dev2);
    SYSCALL	setnok(int nok, int pid);
    SYSCALL screate(int count);
    SYSCALL signal(int sem);
    SYSCALL signaln(int sem, int count);
    SYSCALL	sleep(int n);
    SYSCALL	sleep10(int n);
    SYSCALL sleep100(int n);
    SYSCALL sleep1000(int n);
    SYSCALL sreset(int sem, int count);
    SYSCALL stacktrace(int pid);
    SYSCALL	suspend(int pid);
    SYSCALL	unsleep(int pid);
    SYSCALL	wait(int sem);
    ```
    The implementation of these 27 system calls are in the [sys](sys) directory. You are asked to print the frequency (how many times each system call type is invoked) and the average execution time (how long it takes to execute each system call type on average) of these 27 system calls for each process. In order to do this, you will need to modify the implementation of these 27 types of system calls to trace them whenever they are invoked. To measure the time, XINU provides a global variable named `ctr1000` to track the time (in milliseconds) passed by since the system starts. Please look into [sys/clkinit.c](sys/clkinit.c) and [sys/clkint.S](sys/clkint.S) to see the details.

    You will also need to implement two other functions:

    - `void syscallsummary_start()`: to start tracing the system calls. This function first clears all statistical numbers. All the system calls are invoked after calling this function (and before calling `syscallsummary_stop()`) will be presented in the system call summary. This function keeps all statistical numbers.

    - `void syscallsummary_stop()`: to stop tracing the system calls. 
    
    In other words, these two functions determine the duration in which the system calls are traced.

    To help you complete this task, we provide `test.c` (below) that demonstrates the usage of the functions you will implement (note that this is only the test file and will not be used for grading).
    ```c
    /* test.c - main */

    #include <conf.h>
    #include <kernel.h>
    #include <proc.h>
    #include <stdio.h>
    #include <lab0.h>

    int prX;
    void halt();

    /*------------------------------------------------------------------------
    *  main  --  user main program
    *------------------------------------------------------------------------
    */
    prch(c)
    char c;
    {
        int i;
        sleep(5);	
    }
    int main()
    {
        kprintf("Task 3 (printsyscallsummary)\n");
        syscallsummary_start();        
        resume(prX = create(prch,2000,20,"proc X",1,'A'));
        sleep(10);
        syscallsummary_stop();
        printsyscallsummary();
        return 0;
    }
    ```

    Implement this lab as a set of functions that can be called from `main()`. Each function should reside in a separate file in the [sys](sys/) directory, and should be incorporated into the [Makefile](compile/Makefile) in the [compile](compile/) directory. The files should be named after the functions they are implementing with C files having the `.c` extension and the assembly files having the `.S` extension. For example, the file that will hold `long zfunction(long param)` should be named `zfunction.S`. You should put `syscallsummary_start`, `syscallsummary_stop` functions in the same file as `printsyscallsummary` function and name it as `printsyscallsummary.c`. If you require a header file, please name it `lab0.h` (in the [h](h/) directory). 
    
    **Note**: as you create new files, you may need to update the [Makefile](compile/Makefile) (located in the [compile](compile/) directory) to configure it to compile your files correctly. Just look at what is done for the existing files (e.g., `main.c`) to see what you have to do.

## 5. Turn-in Instructions
1. Preparation

    - Make sure your output follows the output template shown below, as mush as possible:
        ```
        void printprocstks(int priority)
        Process [proc A]
            pid: 11
            priority: 40
            base: 0x00ff0ff0
            limit: 0x00ffffff
            len: 1024
            pointer: 0x 00ffff22
        Process [main]
            pid: 10
            priority: 20
            base: 0x00ff0ff0
            limit: 0x00ffffff
            len: 4096
            pointer: 0x 00ffff33

        void printsyscallsummary()
        Process [pid:20]
            Syscall: sys_scount, count: 2, average execution time: 0 (ms)
        Process [pid:0]
            Syscall: sys_signal, count: 5, average execution time: 0 (ms)
            Syscall: sys_wait, count: 4, average execution time: 0 (ms)
        ```

    - You can write code in [main.c](sys/main.c) to test your procedures, but please note that when we test your programs we will replace the main.c file! Therefore, do not put any functionality in the main.c file.

    - Also, ALL debugging output MUST be turned off before you submit your code.

2. Submission

    We use `git` for assignment submission. Familiarize yourself with git commands. Useful references: [link1](https://education.github.com/git-cheat-sheet-education.pdf), [link2](https://www.atlassian.com/git/glossary). 

    - Go to the [compile](compile/) directory and do `make clean`.

    - Add new files to your repository using `git add filepath` command. Example: `git add sys/zfunction.S` 

    - Create a directory `TMP_unityid`, where `unityid` is your Unity ID (e.g., `TMP_xinurocks`), under the root of the project, and copy all the files you have modified/created, both .c files and .h files, into the new directory. Then, add the directory to the repository by doing `git add TMP_xinurocks` (which will add all the files under the directory).

    - Check if all the necessary changes have been staged by using `git status`. 

    - Then, commit and push:
        ```shell
        git commit -am 'Done'
        git push
        ```
        You can do commit and push whenever you want, but the final submission must be committed/pushed with the message `Done`. For a final check, go to your repository using a web browser, and check if your changes have been pushed.




## 6. Grading Policy

- (10%) Source code can be compiled and the generated image is bootable. Please note that you will also get 0 point for the second part if your source code can not be compiled or can not generate a bootable image.

- (90%) 30 points for each task (losing points on minor problems).

